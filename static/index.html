<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Gemini ìŒì„± ì±—ë´‡</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style> /* ì´ì „ê³¼ ë™ì¼í•œ CSS */ </style>
</head>
<body>
    <div id="container">
        <h1>ìŒì„±/í…ìŠ¤íŠ¸ ì±—ë´‡</h1>
        <div id="status">ì„œë²„ ì—°ê²° ì¤‘...</div>
        <div id="transcript"></div>
        <div id="input-area">
            <button id="recordBtn" disabled>ğŸ¤</button>
            <input type="text" id="text-input" placeholder="í…ìŠ¤íŠ¸ë¡œ ì§ˆë¬¸í•˜ì„¸ìš”..." disabled>
            <button id="send-btn" disabled>ì „ì†¡</button>
        </div>
        <button id="playBtn" class="hidden" style="margin-top: 10px;">â–¶ï¸ ë‹µë³€ ë“£ê¸°</button>
    </div>

    <script>
    // âœ¨âœ¨âœ¨ ìŠ¤í¬ë¦½íŠ¸ ì „ì²´ë¥¼ DOMContentLoaded ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¡œ ê°ì‹¸ ì•ˆì •ì„± í™•ë³´ âœ¨âœ¨âœ¨
    document.addEventListener('DOMContentLoaded', () => {
        const statusDiv = document.getElementById('status');
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const transcriptDiv = document.getElementById('transcript');
        const textInput = document.getElementById('text-input');
        const sendBtn = document.getElementById('send-btn');
        
        let socket, mediaRecorder, audioChunks = [], isRecording = false;
        let lastInputWasVoice = false, audioContext, lastReceivedAudioBlob = null;

        function isIOS() { return /iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream; }

        function connectWebSocket() {
            const socketURL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws`;
            socket = new WebSocket(socketURL);

            socket.onopen = () => {
                statusDiv.textContent = "ì…ë ¥ ë°©ì‹ì„ ì„ íƒí•˜ì„¸ìš”.";
                enableInputs();
                addLog('system', 'ì±—ë´‡ì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.');
            };

            socket.onmessage = async (event) => {
                if (event.data instanceof Blob) {
                    lastReceivedAudioBlob = event.data;
                    const shouldAutoplay = lastInputWasVoice && !isIOS();
                    if (shouldAutoplay) {
                        playReceivedAudio();
                    } else {
                        playBtn.classList.remove('hidden');
                    }
                } else {
                    const message = JSON.parse(event.data);
                    addLog(message.type, message.data);
                    if (message.type === 'error') {
                        statusDiv.textContent = 'ì˜¤ë¥˜ ë°œìƒ. ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”.';
                        disableInputs();
                    }
                }
            };

            socket.onclose = () => { addLog('system', 'ì„œë²„ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.'); disableInputs(); statusDiv.textContent = 'ì—°ê²° ì¢…ë£Œë¨'; };
            socket.onerror = () => { addLog('system', 'ì—°ê²° ì˜¤ë¥˜ ë°œìƒ!'); };
        }

        function addLog(type, text) { /* ... */ }
        function disableInputs() { recordBtn.disabled = true; sendBtn.disabled = true; textInput.disabled = true; }
        function enableInputs() { recordBtn.disabled = false; sendBtn.disabled = false; textInput.disabled = false; }
        
        function sendTextMessage() {
            const text = textInput.value;
            if (!text || !socket || socket.readyState !== WebSocket.OPEN) return;
            lastInputWasVoice = false;
            socket.send(JSON.stringify({ type: 'text', data: text }));
            addLog('user_text', text);
            textInput.value = "";
            disableInputs();
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
                audioChunks = [];
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.readAsDataURL(audioBlob);
                    reader.onloadend = () => {
                        // Base64ë¡œ ì¸ì½”ë”©í•˜ì—¬ ì „ì†¡ (data:audio/webm;base64,xxxx)
                        const base64Audio = reader.result.split(',')[1];
                        if (socket?.readyState === WebSocket.OPEN) {
                            socket.send(JSON.stringify({ type: 'audio', data: base64Audio }));
                        }
                    };
                };
                mediaRecorder.start();
                isRecording = true;
                lastInputWasVoice = true;
                recordBtn.textContent = "ğŸ™ï¸";
                recordBtn.classList.add('recording');
                disableInputs(); recordBtn.disabled = false;
            } catch (err) { alert("ë§ˆì´í¬ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); }
        }

        function stopRecording() { if (mediaRecorder) mediaRecorder.stop(); isRecording = false; recordBtn.textContent = "ğŸ¤"; recordBtn.classList.remove('recording'); disableInputs(); }
        
        async function playReceivedAudio() {
            if (!lastReceivedAudioBlob) return;
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') await audioContext.resume();
            
            try {
                const arrayBuffer = await lastReceivedAudioBlob.arrayBuffer();
                const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);
                const source = audioContext.createBufferSource();
                source.buffer = decodedBuffer;
                source.connect(audioContext.destination);
                source.start(0);
                playBtn.classList.add('hidden');
                source.onended = () => { enableInputs(); addLog('system', 'ë‹µë³€ ì¬ìƒì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.'); };
            } catch(e) { console.error(e); enableInputs(); }
            finally { lastReceivedAudioBlob = null; }
        }

        recordBtn.onclick = () => { isRecording ? stopRecording() : startRecording(); };
        sendBtn.onclick = sendTextMessage;
        textInput.addEventListener('keyup', e => { if (e.key === 'Enter') sendTextMessage(); });
        playBtn.onclick = playReceivedAudio;
        
        connectWebSocket();
    });
    </script>
</body>
</html>